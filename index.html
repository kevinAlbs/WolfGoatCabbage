<!doctype html>

<html lang="en">
<head>
    <meta charset="utf-8">

    <title>Wolf, Goat, Cabbage</title>
    <meta name="description" content="">
    <meta name="author" content="Kevin Albertson">
    <link rel="icon" type="image/png" href="img/favicon.png">

    <style type="text/css">
        #container {
            width: 900px;
            height: 450px;
            background: #EEE;
            margin: 10px auto;
            position: relative;
        }
        #mute {
            position: absolute;
            display: block;
            top: 10px;
            right: 10px;
            text-indent: -9999pt;
            width: 66px;
            height: 54px;
            overflow: hidden;
            background: url("img/mute.png") no-repeat;
            opacity: .5;
            transition: opacity .1s linear;
        }
        #mute[data-muted=false] {
            background-position: 0px 0px;
        }
        #mute[data-muted=true] {
            background-position: -66px 0px;
        }
        #mute:hover {
            opacity: 1;
        }
    </style>

    <!--[if lt IE 9]>
    <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
</head>

<body>
    <div id="container">
        <div id="game"></div>
        <a href="#" id="mute" data-muted="false" title="Mute/Unmute">Mute</a>
    </div>
    <script src="js/phaser.min.js"></script>
    <script>
        var game = new Phaser.Game(900, 450, Phaser.AUTO, "game", {
            preload: preload,
            create: create,
            update: update
        }, false, false, null);

        var skies = [];
        var kLakeStartX = 140, kLakeEndX = 370;
        var kBarnStartX = 618, kBarnStepStartX = 597;
        var kCamBeforeFarm = 190, kCamAfterFarm = 650 - 300, kCamBarn = 650; // TODO: remove kCamBarn constant in favor of position
        var kCamMenu = 950, kCamEnd = 950;
        var kGroundY = 89;
        var kLeft = -1, kRight = 1, kCenter = 0;
        var kIn = 0, kNotIn = 1;
        var water = [];

        var farmer = {
            state: {
                dir: 1,
                boat: kNotIn, // in
                body: "idle", // walking, stairs, sleeping
                pickingUp: "none", // goat, wolf, cabbage, gun
                x: 100,
                y: 80,
                onStairs: false,
                floor: 1
            },
            stairsAnimPlaying: 0, // 1 for left, 2 for right
            body: null,
            sprite: null,
            deathBody: null,
            sleepingBody: null,
            width: 20,
            readyToDie: false
        };

        var goat = {
            state: {
                dir : 1,
                body: "idle", // walking, eating, held, dead
                boat: kNotIn,
                x: 55,
                y: 93
            },
            sprite: null,
            width: 24,
            goingForKill: false,
        };

        var cabbage = {
            state: {
                boat: kNotIn,
                x: 82,
                y: 93,
                body: "idle", // dead, held
            },
            sprite: null,
            width: 12
        };

        var wolf = {
            state: {
                dir : 1,
                body: "idle", // walking, eating, held
                boat: kNotIn,
                x: 20,
                y: 94
            },
            sprite: null,
            width: 26,
            goingForKill: false,
        };

        var boat = {
            state: {
                body: "idle", // moving
                dir: 1,
                side: kLeft, // center/right
                yOffset: 0,
                x: 178,
                y: 98
            },
            sprite: null,
            width: 69
        };

        var gun = {
            sprite: null,
            width: 23
        };

        var textDisplay = {
            graphics: null,
            text: null, // Currently displayed text.
            newText: null, // Text requested to display this frame.
            bitmapText: null,
        };

        // Yes - cabbage is an animal.
        var animals = new Map([["goat", goat], ["cabbage", cabbage], ["wolf", wolf]]); 
        var actors = new Map(animals.entries());
        actors.set("farmer", farmer);

        var keysDownHandled = {};

        var targetCameraX = 0;

        var losingScene = "none"; // wolf_eats_goat, goat_eats_cabbage

        var title = {
            showing: false,
            group: null
        };

        var restartState = null;

        var isTransitioning = false, isFadingOut = false;
        var transition = {
            active: false,
            startTime: 0,
            duration: 0
        };

        var gameState = {
            day: 1,
            screen: "menu", // game
            room: "outside", // barn, end
            sky: {
                changing: false,
                nightWatch: 0
            },
            endSequence : {
                active: false,
                step: 0,
                decrementTimer: 0,
                rate: 1000, // rate at which clock step decreases. Decreases as step increases.
                highlightTimer: 0, // highlights the (space)
            },
            hasRiddenBoat: false
        };

        var stateJustReset = false;
        var muted = false;

        // Map state names to implementing functions.
        var screenTick = {}, roomTick = {}, farmerDayTick = {};
        var muteButton = document.getElementById("mute");
        var backgroundMusic = null, audioKeyPlaying = "", audioPlaying = null;
        var noise = null, noiseState = "unstarted"; // fading, looping
        var gunshot = null;

        var timers = {}; // -1 means unlocked, 0 means finished, > 0 means counting down.
        
        var water = {
            group: null, // group containing water sprites, so sprites are relatively positioned.
            data: [],
        }; 

        // Caller's responsibility to reset timer.
        function timerWait(key, duration) {
            if (!timers.hasOwnProperty(key) || timers[key] == -1) {
                timers[key] = duration;
            }
            timers[key] -= game.time.elapsed;
            if (timers[key] <= 0) timers[key] = 0;
            return timers[key];
        };

        function timerReset(key) {
            timers[key] = -1;
        }

        function updateMuteButton() {
            muteButton.setAttribute("data-muted", muted ? "true" : "false");
        }

        function transitionState(duration, callback) {
            if (isTransitioning) return;
            isTransitioning = true;
            isFadingOut = true;
            game.camera.onFadeComplete.add(() => {
                callback();
                isFadingOut = false;
                game.camera.onFlashComplete.add(() => {
                    isTransitioning = false;
                    // Clear current event listeners.
                    game.camera.onFadeComplete.removeAll();
                    game.camera.onFlashComplete.removeAll();
                    game.camera.resetFX();
                });
                game.camera.flash(0x000000, duration, true)
            });
            game.camera.fade(0x000000, duration, true);
        }

        // Returns true if this keycode is down. If it returns true, it will wait until it is released
        // and re-pressed before returning true again.
        function isPressed(keycode) {
            if (game.input.keyboard.isDown(keycode)) {
                if (keysDownHandled[keycode]) {
                    return false;
                } else {
                    keysDownHandled[keycode] = true;
                    return true;
                }
            }
        }

        function isDown(keycode) {
            if (losingScene == "none" && !isTransitioning) {
                return game.input.keyboard.isDown(keycode);
            }
        }

        function isRiddleSolved() {
            var solved = true;
            animals.forEach((animal, animalName) => { solved = solved && animal.state.x >= kLakeEndX && farmer.state.pickingUp != animalName; });
            return solved;
        }

        function lakeSide(obj) {
            return obj.state.x <= kLakeStartX ? kLeft : kRight;
        }

        function playIfNotPlaying(key) {
            if (audioKeyPlaying != key) {
                // Stop all sounds.
                backgroundMusic.stop();
                audioPlaying = backgroundMusic.play(key, 0, 1, true);
                audioKeyPlaying = key;
            }
        }

        function showTitle(msg, restart) {
            if (restart && isPressed(Phaser.KeyCode.SPACEBAR)) {
                if (title.showing) title.group.destroy();
                title.showing = false;
                restartGame();
                return;
            }

            if (title.showing) {
                title.group.x = game.camera.x / game.camera.scale.x;
                return;
            }
            title.showing = true;
            title.group = game.add.group();
            title.group.add(game.add.sprite(10, 10, "title"));
            if (msg) title.group.add(game.add.bitmapText(85, 12, "font", msg, 16));
            if (restart) title.group.add(
                game.add.bitmapText(10, 30, "font", "(space) to restart", 16));
        }

        // Returns boolean indicating success.
        function displayText(msg) {
            // If multiple attempts, only take the first.
            if (textDisplay.newText) return false;
            textDisplay.newText = msg;
            return true;
        }

        function prompt(msg) {
            // If we're in the losing scene or we've already prompted something this frame, skip.
            if (losingScene != "none" || !displayText(msg)) return;
            return isPressed(Phaser.KeyCode.SPACEBAR);
        }

        // Called at the end of the frame to render whichever text is displayed last.
        function tickDisplayText() {
            // If the text display has been created or changed, we need to re-render.
            if (textDisplay.newText != textDisplay.text) {
                // Display created/changed text.
                textDisplay.graphics.removeChildren();
                textDisplay.graphics.clear();
                if (textDisplay.newText != null) {
                    textDisplay.graphics.beginFill(0x000000);
                    textDisplay.graphics.drawRect(10, 130, 280, 11);
                    textDisplay.graphics.endFill();

                    // End sequence should separate the word "(space)" TODO.
                    textDisplay.bitmapText = game.add.bitmapText(150, 134, "font", textDisplay.newText, 16);
                    textDisplay.bitmapText.anchor.set(.5, .5);
                    textDisplay.graphics.addChild(textDisplay.bitmapText);
                    textDisplay.text = textDisplay.newText;
                }
                textDisplay.text = textDisplay.newText;
            }

            if (gameState.room == "end" && textDisplay.bitmapText) {
                var diff = Math.min(255, Math.floor(255 * gameState.endSequence.step  / 70));
                if (gameState.endSequence.highlightTimer > 0) {
                    diff = Math.max(diff, 255 * gameState.endSequence.highlightTimer / 250);
                }
                textDisplay.bitmapText.tint = 0xFF0000 | (0xFF - diff) | ((0xFF - diff) << 8);
            }

            textDisplay.newText = null;
        }

        function restartGame() {
            game.camera.x = 0;
            losingScene = "none";
            setCompleteState(restartState);
        }

        function getCompleteState() {
            return {
                farmer: Phaser.Utils.extend(true, {}, farmer.state),
                cabbage: Phaser.Utils.extend(true, {}, cabbage.state),
                wolf: Phaser.Utils.extend(true, {}, wolf.state),
                goat: Phaser.Utils.extend(true, {}, goat.state),
                boat: Phaser.Utils.extend(true, {}, boat.state),
                gameState: Phaser.Utils.extend(true, {}, gameState)
            }
        }

        function setCompleteState(state) {
            Phaser.Utils.extend(true, farmer.state, state.farmer);
            Phaser.Utils.extend(true, wolf.state, state.wolf);
            Phaser.Utils.extend(true, goat.state, state.goat);
            Phaser.Utils.extend(true, cabbage.state, state.cabbage);
            Phaser.Utils.extend(true, boat.state, state.boat);
            Phaser.Utils.extend(true, gameState, state.gameState);
            updateMuteButton();
            stateJustReset = true;
        }

        function tempSet() {
            wolf.state.x = kLakeEndX + 20;
            goat.state.x = kLakeEndX + 30;
            cabbage.state.x = kLakeEndX + 40;
            farmer.state.x = kLakeEndX + 50;
            gameState.hasRiddenBoat = true;
        }

        function saveState() {
            window.localStorage.setItem("state", JSON.stringify(getCompleteState()));
        }

        function loadState() {
            var state = JSON.parse(window.localStorage.getItem("state"));
            if (state) setCompleteState(state);
        }

        function clearState() {
            window.localStorage.removeItem("state");
        }

        // Applies boat offset if on boat.
        function yPos(actor) {
            return actor.state.y + (actor.state.boat == kIn ? boat.state.yOffset : 0);
        }

        function boundCheckActor(actor1, actor2) {
            var a2hw = actor2.width / 2;
            return boundCheck(actor1, actor2.state.x - a2hw, actor2.state.x + a2hw);
        }

        // Returns -1 if left of, +1 if right of, 0 if strictly inside.
        function boundCheck(actor, lower, upper) {
            var hw = actor.width / 2;
            if (actor.state.x - hw < lower) return kLeft;
            if (actor.state.x + hw > upper) return kRight;
            return kIn;
        }

        function boundXActor(actor1, actor2) {
            var a2hw = actor2.width / 2;
            return boundX(actor1, actor2.state.x - a2hw, actor2.state.x + a2hw);
        }

        function boundX(actor, lower, upper) {
            var hw = actor.width / 2;
            if (actor.state.x - hw < lower) actor.state.x = lower + hw;
            if (actor.state.x + hw > upper) actor.state.x = upper - hw;
        }

        function preload() {
            game.load.image("title", "img/title.png");
            game.load.spritesheet("bg", "img/bg.png?v2", 1250, 150);
            game.load.spritesheet("goat", "img/goat.png?v2", 25, 20);
            game.load.spritesheet("wolf", "img/wolf.png?v3", 31, 20);
            game.load.spritesheet("cabbage", "img/cabbage.png", 12, 8);
            game.load.image("boat", "img/boat.png?v3");
            game.load.image("boat-back", "img/boat-back.png");
            game.load.spritesheet("farmer", "img/farmer.png?v7", 30, 44);
            game.load.image("farmer-sleeping", "img/farmer-sleeping.png");
            game.load.bitmapFont("font", "img/font.png", "img/font.fnt");
            game.load.image("barn-front", "img/barn-front.png?v2");
            game.load.image("gun", "img/gun.png");
            game.load.spritesheet("farmer-death", "img/farmer-death.png?v3", 70, 53);
            game.load.audio("sounds", "snd/all.mp3?v8");
            game.load.image("water", "img/water.png?v2");
            game.load.image("barn-fg", "img/barn-fg.png");
        }

        function create() {
            restartState = getCompleteState();

            game.camera.scale.set(3, 3);
            game.camera.bounds = null;

            skies = [
                { bg: game.add.sprite(0, 0, "bg", 5), ttl: 0 },
                { bg: game.add.sprite(0, 0, "bg", 3), ttl: 15 * 1000 },
                { bg: game.add.sprite(0, 0, "bg", 1), ttl: 15 * 1000 },
                { bg: game.add.sprite(0, 0, "bg", 0), ttl: 15 * 1000 }
            ];
            
            water.group = game.add.group()
            water.group.x = 120;
            water.group.y = 110;
            
            for (var i = 0; i < 91; i++) {
                var ws = game.add.sprite(i * 3, 0, "water");
                ws.anchor.set(.5, 0);
                ws.scale.set(3, 100);
                water.group.add(ws);
                water.data.push({ vel: 0, sprite: ws, velocityDriven: i % 15 == 0 });
            }
            
            game.add.sprite(0, 0, "bg", 7);
            
            // Add menu sprites.
            game.add.sprite(kCamMenu + 10, 10, "title");
            game.add.bitmapText(kCamMenu + 65, 50, "font", "wolf eats goat", 16);
            game.add.bitmapText(kCamMenu + 165, 50, "font", "goat eats cabbage", 16);
            game.add.sprite(kCamMenu + 35, 50, "wolf");
            game.add.sprite(kCamMenu + 139, 47, "goat");
            game.add.sprite(kCamMenu + 253, 55, "cabbage");
            game.add.bitmapText(kCamMenu + 107, 64, "font", "bring them across", 16);

            boat.back = game.add.sprite(0, 0, "boat-back");
            boat.back.anchor.set(.5, .5);

            gun.sprite = game.add.sprite(778, 40, "gun");
            gun.sprite.anchor.set(.5, .5);

            farmer.sprite = game.add.group();
            farmer.body = game.add.sprite(0, 0, "farmer");
            farmer.body.anchor.set(.5, .5);
            farmer.body.animations.add("idle", [0]);
            farmer.body.animations.add("walking", [1,2,3,4,5,6], 6);
            farmer.body.animations.add("idle-cabbage", [7]);
            farmer.body.animations.add("walking-cabbage", [8,9,10,11,12,13], 6);
            farmer.body.animations.add("idle-goat", [14]);
            farmer.body.animations.add("walking-goat", [15,16,17,18,19,20], 6);
            farmer.body.animations.add("idle-wolf", [21]);
            farmer.body.animations.add("walking-wolf", [22,23,24,25,26,27], 6);
            farmer.body.animations.add("stairs-1", [28,29,30], 6);
            farmer.body.animations.add("stairs-2", [31,32,33], 6);
            farmer.body.animations.add("idle-gun", [34]);
            farmer.body.animations.add("walking-gun", [35,36,37,38,39,40], 6);
            farmer.sprite.add(farmer.body);

            farmer.deathBody = game.add.sprite(0, -2, "farmer-death");
            farmer.deathBody.anchor.set(.5, .5);
            farmer.deathBody.animations.add("death", [13, 14, 15, 16, 17, 18, 19], 8, false);
            farmer.sprite.add(farmer.deathBody);

            farmer.sleepingBody = game.add.sprite(kCamBarn + 42, 48, "farmer-sleeping");
            farmer.sleepingBody.visible = false;

            cabbage.sprite = game.add.sprite(0, 0, "cabbage");
            cabbage.sprite.anchor.set(.5, 0);
            cabbage.sprite.animations.add("idle", [0]);
            cabbage.sprite.animations.add("dead", [1]);

            wolf.sprite = game.add.sprite(0, 0, "wolf");
            wolf.sprite.anchor.set(.5, .5);
            wolf.sprite.animations.add("idle", [1, 2, 0, 2], 6);
            wolf.sprite.animations.add("walking", [3, 4, 5, 6], 8);
            wolf.sprite.animations.add("eating", [7, 8, 9, 10], 5);

            // Since sprite is updated with state, initial position is overwritten on first frame.
            goat.sprite = game.add.sprite(0, 0, "goat");
            goat.sprite.anchor.set(.5, .5);
            goat.sprite.animations.add("idle", [0]);
            goat.sprite.animations.add("walking", [1,2,3,4,5,6,7,8], 5);
            goat.sprite.animations.add("eating", [9,10,11], 3);
            goat.sprite.animations.add("dead", [12]);

            boat.sprite = game.add.sprite(0, 0, "boat");
            boat.sprite.anchor.set(.5, .5);

            // Is setting equal ok?
            game.input.keyboard.onUpCallback = function(keyEvent) {
                keysDownHandled[keyEvent.keyCode] = false;
            };

            // Add foreground.
            game.add.sprite(605, 35, "barn-front");
            game.add.sprite(650, 0, "barn-fg");

            skies[0].overlay = game.add.sprite(0, 0, "bg", 6);
            skies[1].overlay = game.add.sprite(0, 0, "bg", 4);
            skies[2].overlay = game.add.sprite(0, 0, "bg", 2);

            textDisplay.graphics = game.add.graphics(0, 0);
            textDisplay.graphics.fixedToCamera = true;

            backgroundMusic = game.add.audio("sounds");
            backgroundMusic.addMarker("bg", 0, 66.56, 1, true);
            backgroundMusic.addMarker("reverse", 66.56, 43.4, 1, true);

            gunshot = game.add.audio("sounds");
            gunshot.addMarker("gunshot", 116.06, 1.2, false);

            noise = game.add.audio("sounds");
            noise.addMarker("noise", 110.26, 5, 1, true);

            loadState();
        }

        // Checks if farmer can get on or off boat, and may bound farmer position to lake exterior.
        function farmerBoatTick() {
            var fx = farmer.state.x, fw = farmer.width, fhw = farmer.width / 2;
            var farmerSide = Math.abs(fx - kLakeStartX) < Math.abs(fx - kLakeEndX) ? kLeft : kRight;

            // Check for getting in or out of boat.
            if (farmer.state.boat == kNotIn
                && boundCheck(farmer, kLakeStartX - fw, kLakeEndX + fw) == kIn) {
                // Farmer is at lake boundary.
                var boatFilled = false;
                animals.forEach((animal) => {
                    boatFilled = boatFilled || animal.state.boat == kIn;
                });
                boatFilled = boatFilled && farmer.state.pickingUp != "none";

                if (farmerSide == kLeft) {
                    if (boat.state.side != kLeft) {
                        fx = farmer.state.x = kLakeStartX - fhw;
                    } else if (boatFilled) {
                        displayText("not enough room");
                        fx = farmer.state.x = kLakeStartX - fhw;
                    } else {
                        fx = farmer.state.x = boat.state.x - 20;
                        farmer.state.boat = kIn;
                    }
                } else {
                    if (boat.state.side != kRight) {
                        fx = farmer.state.x = kLakeEndX + fhw;
                    } else if (boatFilled) {
                        displayText("not enough room");
                    } else {
                        fx = farmer.state.x = boat.state.x + 20;
                        farmer.state.boat = kIn;
                    }
                }
            }

            if (farmer.state.boat == kIn) {
                // Check if farmer can get out of boat.
                var bx = boat.state.x, bhw = boat.sprite.width / 2;
                var farmerBoundCheck = boundCheck(farmer, bx - bhw + 4, bx + bhw - 4);
                var boundFarmer = () => { boundX(farmer, bx - bhw + 3, bx + bhw - 3); };
                // Cannot leave if boat is moving or the farmer on opposite side.
                if (boat.state.body == "moving") {
                    boundFarmer();
                } else {
                    // Farmer can leave if he is moving towards the same side as the boat.
                    // Farmer can ride the boat to the other side if he's moving towards that side.
                    if (farmerBoundCheck == boat.state.side) {
                        // Leave on same side.
                        farmer.state.boat = kNotIn;
                        farmer.state.x = farmerBoundCheck == kLeft ? kLakeStartX - fhw - 2 : kLakeEndX + fhw + 2;
                    } else if (farmerBoundCheck == boat.state.side * -1) {
                        // Prompt to ride.
                        boundFarmer();
                        if (prompt("(space) to ride boat")) {
                            boat.state.body = "moving";
                            boat.state.side = "center";
                            boat.state.dir = farmerBoundCheck;
                            gameState.hasRiddenBoat = true;
                        }
                    }
                }
            }
        }

        farmerDayTick[1] = function() {
            farmerBoatTick();

            var fx = farmer.state.x;
            var fhw = farmer.width / 2;

            if (!isRiddleSolved()) {
                fx = farmer.state.x = Math.min(fx, kCamBeforeFarm + 300 - fhw);
                // Check for picking up or dropping animals.
                if (farmer.state.pickingUp == "none") {
                    animals.forEach((actor, actorName) => {
                        if (Math.abs(farmer.state.x - actor.state.x) < 4) {
                            if (prompt("(space) to pick up " + actorName)) {
                                farmer.state.pickingUp = actorName;
                                actor.state.body = "held";
                            }
                        }
                    });
                } else {
                    if (prompt("(space) to drop " + farmer.state.pickingUp)) {
                        var animal = animals.get(farmer.state.pickingUp);
                        animal.state.body = "idle";
                        farmer.state.pickingUp = "none";
                    }
                }
            }

            // Check if farmer can go to sleep.
            if (farmer.state.floor == 2 && boundCheck(farmer, 670 - fhw, 740 + fhw) == kIn) {
                if (gameState.sky.nightWatch >= 45 * 1000) {
                    if (prompt("(space) to sleep")) {
                        farmer.state.body = "sleeping";
                        transitionState(3000, () => {
                            gameState.day = 2;
                            boat.state.x = kLakeStartX + boat.sprite.width / 2;
                            boat.state.side = kLeft;
                            farmer.state.body = "idle";
                        });
                    }
                } else {
                    displayText("too early to sleep");
                }
            }
        };

        farmerDayTick[2] = function() {
            var fx = farmer.state.x, fhw = farmer.width / 2;
            if (farmer.state.pickingUp == "none") {
                var gx = gun.sprite.x, ghw = gun.sprite.width / 2;
                if (farmer.state.floor == 2 && farmer.state.x > gx - ghw && farmer.state.x < gx + ghw) {
                    if (prompt("(space) to pick up gun")) {
                        farmer.state.pickingUp = "gun";
                        gun.sprite.visible = false;
                    }
                }
            }
            if (farmer.state.x < kLakeEndX + fhw + 28) {
                // Ensure farmer is well within right boundary so blood stays on ground.
                farmer.state.x = kLakeEndX + fhw + 28;
            }

            // If on death area, show death body.
            if (gameState.room == "outside" && farmer.state.pickingUp == "gun" && fx < kLakeEndX + fhw + 35 && farmer.state.body == "idle") {
                farmer.readyToDie = true;
                if (prompt("(space) to end it")) {
                    gameState.room = "end";
                }
            } else {
                farmer.readyToDie = false;
            }
        };

        function farmerStateTransitions() {
            var fx = farmer.state.x;
            var fhw = farmer.width / 2;

            // Check for state transitions.
            if (farmer.state.body == "walking")
                farmer.state.x = fx = fx + farmer.state.dir * .035 * game.time.elapsed;

            if (farmer.state.body == "walking" || farmer.state.body == "idle") {
                // Check if farmer should start walking.
                if (isDown(Phaser.KeyCode.RIGHT)) {
                    farmer.state.dir = kRight;
                    farmer.state.body = "walking";
                } else if (isDown(Phaser.KeyCode.LEFT)) {
                    farmer.state.dir = kLeft;
                    farmer.state.body = "walking";
                } else {
                    farmer.state.body = "idle";
                }
            }

            farmerDayTick[gameState.day]();

            // Check if farmer is inside/entering the barn or at a boundary.
            if (gameState.room == "outside") {
                farmer.state.y = 80;
                if (farmer.state.x > kBarnStartX) {
                    // The first time the farmer enters the barn the sky turns.
                    gameState.sky.active = true;
                    transitionState(1000, () => {
                        gameState.room = "barn";
                        farmer.state.x = fx = kCamBarn + 10;
                    });
                } else if (farmer.state.x > kBarnStepStartX) {
                    farmer.state.y = 73;
                } else if (fx <= fhw) {
                    farmer.state.x = fx = fhw;
                }
            } else if (gameState.room == "barn") {
                if (!farmer.state.onStairs) farmer.state.y = farmer.state.floor == 1 ? 124 : 50;

                // Check if the farmer is on or entering the staircase.
                if (farmer.state.onStairs) {
                    // Show a little jump on the end of each step animation.
                    var stairAnimFinished = farmer.body.animations.currentAnim.isFinished;
                    var stepScale = stairAnimFinished ? 7 : 0.3;
                    if (isDown(Phaser.KeyCode.UP)) {
                        farmer.state.dir = kRight;
                        farmer.state.body = "stairs";
                        farmer.state.x += stepScale * 0.015 * game.time.elapsed;
                        farmer.state.y += stepScale * -0.025 * game.time.elapsed;

                        if (stairAnimFinished)
                            farmer.stairsAnimPlaying = farmer.stairsAnimPlaying == 1 ? 2 : 1;

                        if (farmer.state.y <= 50) {
                            farmer.state.onStairs = false;
                            farmer.state.floor = 2;
                            farmer.state.body = "idle";
                        }
                    } else if (isDown(Phaser.KeyCode.DOWN)) {
                        farmer.state.dir = kLeft;
                        farmer.state.body = "stairs";
                        farmer.state.x += stepScale * -0.015 * game.time.elapsed;
                        farmer.state.y += stepScale * 0.025 * game.time.elapsed;

                        if (stairAnimFinished)
                            farmer.stairsAnimPlaying = farmer.stairsAnimPlaying == 1 ? 2 : 1;

                        if (farmer.state.y >= 125) {
                            farmer.state.onStairs = false;
                            farmer.state.floor = 1;
                            farmer.state.body = "idle";
                        }
                    }
                } else {
                    farmer.stairsAnimPlaying = 0;
                    if (fx >= 850 && fx < 862 && isPressed(Phaser.KeyCode.UP)) {
                        farmer.state.onStairs = true;
                        farmer.state.x = 859;
                        farmer.stairsAnimPlaying = 1;
                    } else if (fx >= 890 && fx <= 910 && isPressed(Phaser.KeyCode.DOWN)) {
                        farmer.state.onStairs = true;
                        farmer.state.x = 904;
                        farmer.stairsAnimPlaying = 1;
                    }
                }

                if (fx <= kCamBarn) {
                    if (farmer.state.floor == 1) {
                        transitionState(1000, () => {
                            farmer.state.x = fx = kBarnStartX - 1;
                            gameState.room = "outside";
                        });
                    }
                } else if (fx <= kCamBarn + fhw && farmer.state.floor == 2) {
                    farmer.state.x = fx = kCamBarn + fhw;
                } else if (fx > kCamBarn + 300 - fhw) {
                    farmer.state.x = kCamBarn + 300 - fhw;
                }
            }
        }

        function farmerTick() {
            farmerStateTransitions();

            var fx = farmer.state.x;
            var fhw = farmer.width / 2;

            farmer.deathBody.visible = farmer.sleepingBody.visible = farmer.body.visible = false;
            if (farmer.readyToDie || gameState.room == "end") farmer.deathBody.visible = true;
            else if (farmer.state.body == "sleeping") farmer.sleepingBody.visible = true;
            else farmer.body.visible = true;

            // Apply farmer state to farmer sprite.
            farmer.body.scale.set(farmer.state.dir, 1);
            farmer.deathBody.scale.set(farmer.state.dir, 1);

            if (farmer.state.body == "stairs") {
                // Stairs is a special case since we don't loop the animations, but alternate them.
                var currentAnim = farmer.body.animations.currentAnim.name;
                var stairAnim = "stairs-" + farmer.stairsAnimPlaying;
                if (stairAnim != currentAnim) farmer.body.animations.play(stairAnim);
            } else {
                var farmerAnim = farmer.state.body;
                // If the farmer is picking up an animal or gun, tack on to the current animation.
                if (farmer.state.pickingUp != "none") {
                    farmerAnim += "-" + farmer.state.pickingUp;
                }
                farmer.body.animations.play(farmerAnim)
            }

            farmer.sprite.position.x = farmer.state.x;
            farmer.sprite.position.y = yPos(farmer);
        }

        function boatTick() {
            var bx = boat.state.x, bhw = boat.sprite.width / 2;
            // Check for state transitions.
            // Move everything on the boat up and down.
            boat.state.yOffset = Math.sin(game.time.elapsedSince(0) * .005) / 2;

            if (boat.state.body == "moving") {
                var deltaX = boat.state.dir * game.time.elapsed * .05;
                actors.forEach((actor) => {
                    actor.state.x += actor.state.boat == kIn ? deltaX : 0;
                });
                bx = boat.state.x = bx + deltaX;
                if (boat.state.dir == kRight) {
                    if (bx > kLakeEndX - bhw) {
                        boat.state.side = kRight;
                        boat.state.body = "idle";
                    }
                } else {
                    if (bx < kLakeStartX + bhw) {
                        boat.state.side = kLeft;
                        boat.state.body = "idle";
                    }
                }
            }

            // Apply boat state to boat sprite.
            boat.sprite.position.x = boat.state.x;
            boat.sprite.position.y = boat.state.y + boat.state.yOffset;
            boat.back.position.set(boat.sprite.position.x, boat.sprite.position.y);
        }

        function animalTick() {
            // Check for state transitions.
            if (gameState.day == 2) {
                wolf.sprite.visible = false;
                goat.sprite.visible = false;
                cabbage.sprite.visible = false;
                return;
            }
            // Apply properties common to all animals.
            actors.forEach((actor, actorName) => {
                if (actorName == "farmer") return;
                if (actor.state.body == "held") {
                   actor.state.boat = farmer.state.boat;
                   actor.state.x = farmer.sprite.position.x;
                   //actor.state.y = 75;
                   actor.state.dir = farmer.state.dir;
                   actor.sprite.visible = false;
                } else {
                   //actor.state.y = 88;
                   actor.sprite.visible = true;
                }
            });

            // Check if the losing scene should occur.
            if (boat.state.body == "moving") {
                if (lakeSide(wolf) == lakeSide(goat) && wolf.state.boat == kNotIn
                    && goat.state.boat == kNotIn) {
                    losingScene = "wolf_eats_goat";
                } else if (lakeSide(goat) == lakeSide(cabbage) && goat.state.boat == kNotIn
                    && cabbage.state.boat == kNotIn) {
                    losingScene = "goat_eats_cabbage";
                }
            }

            if (losingScene == "wolf_eats_goat" && !wolf.goingForKill && timerWait("losingDelay", 1000) == 0) {
                wolf.goingForKill = true;
                timerReset("losingDelay");
            } else if (losingScene == "goat_eats_cabbage" && !goat.goingForKill && timerWait("losingDelay", 1000) == 0) {
                goat.goingForKill = true;
                timerReset("losingDelay");
            }

            if (wolf.goingForKill) {
                wolf.state.body = "walking";
            }

            if (goat.goingForKill) {
                goat.state.body = "walking";
            }

            if (wolf.state.body == "walking") {
                var diff = goat.state.x - wolf.state.x;
                if (Math.abs(diff) > 13) {
                    wolf.state.dir = Math.sign(diff);
                    wolf.state.x += .05 * wolf.state.dir * game.time.elapsed;
                } else {
                    wolf.state.body = "eating";
                    wolf.goingForKill = false;
                    goat.state.body = "dead";
                }
            } else if (wolf.state.body == "eating") {
                // Show title screen once goat is completely eaten.
                showTitle("Wolves eat goats.", true);
            }

            if (goat.state.body == "walking") {
                var diff = cabbage.state.x - goat.state.x;
                if (Math.abs(diff) > 10) {
                    goat.state.dir = Math.sign(diff);
                    goat.state.x += .04 * goat.state.dir * game.time.elapsed;
                } else {
                    goat.goingForKill = false;
                    goat.state.body = "eating";
                    cabbage.state.body = "dead";
                }
            } else if (goat.state.body == "eating") {
                showTitle("Goats eat cabbages.", true);
            }

            // Apply states common to all.
            actors.forEach((actor, actorName) => {
                if (actorName == "farmer") return;
                actor.sprite.position.x = actor.state.x;
                actor.sprite.position.y = yPos(actor);
            });

            cabbage.sprite.animations.play(cabbage.state.body);
            goat.sprite.scale.set(goat.state.dir, 1);
            goat.sprite.animations.play(goat.state.body);
            wolf.sprite.scale.set(wolf.state.dir, 1);
            wolf.sprite.animations.play(wolf.state.body);
        }

        function skyTick() {
            if (gameState.day == 1 && gameState.sky.active) {
                gameState.sky.nightWatch += game.time.elapsed;
                var accumulated = gameState.sky.nightWatch;
                accumulated -= 5 * 1000; // First five seconds don't experience change.

                // Last sky is the the earliest.
                for (var i = skies.length - 1; i >= 0; i--) {
                    if (accumulated > skies[i].ttl) {
                        // If i == 0, it is night time.
                        skies[i].bg.alpha = i == 0 ? 1 : 0;
                        if (i < skies.length - 1) skies[i].overlay.alpha = skies[i].bg.alpha;
                    } else if (accumulated > 0) {
                        var ratio = accumulated / skies[i].ttl;
                        // Fade out current background and overlay.
                        skies[i].bg.alpha = 1 - ratio;
                        if (i < skies.length - 1) skies[i].overlay.alpha = 1 - ratio;
                        // Fade in next overlay.
                        if (i > 0) {
                            skies[i-1].overlay.alpha = ratio;
                            skies[i-1].bg.alpha = 1;
                            i--; // Skip iteration so it doesn't get hidden.
                        }
                    } else {
                        // If this is the beginning, just show it.
                        if (i == skies.length - 1) skies[i].bg.alpha = 1;
                        // Otherwise, this is behind any skies fading in.
                        else skies[i].overlay.alpha = 0;
                    }
                    accumulated -= skies[i].ttl;
                }
            } else {
                // Just show daytime.
                for (var i = 0; i < skies.length - 1; i++) skies[i].overlay.alpha = 0;
                skies[skies.length - 1].bg.alpha = 1;
            }
        }

        function endSequenceTick() {
            function finished() {
                return gameState.endSequence.step >= 70;
            }

            function inRange(lower, higher) {
                return gameState.endSequence.step >= lower && gameState.endSequence.step < higher;
            }

            farmer.body.visible = false;
            farmer.deathBody.visible = true;

            if (!finished()) {
                displayText("(space) to end it");
                farmer.deathBody.frame = 1;
                gameState.endSequence.highlightTimer -= game.time.elapsed;
                gameState.endSequence.decrementTimer -= game.time.elapsed;
                if (gameState.endSequence.decrementTimer <= 0) {
                    gameState.endSequence.decrementTimer = gameState.endSequence.rate;
                    gameState.endSequence.step = Math.max(0, gameState.endSequence.step - 1);
                }
                gameState.endSequence.rate = 1000 - (gameState.endSequence.step / 70) * 850;

                if (isPressed(Phaser.KeyCode.SPACEBAR)) {
                    gameState.endSequence.step++;
                    gameState.endSequence.highlightTimer = 250;
                }

                if (inRange(5, 10)) {
                    farmer.deathBody.frame = 2;
                } else if (inRange(10, 15)) {
                    farmer.deathBody.frame = 3;
                } else if (inRange(15, 20)) {
                    farmer.deathBody.frame = 4;
                } else if (inRange(20, 25)) {
                    farmer.deathBody.frame = 5;
                } else if (inRange(25, 30)) {
                    farmer.deathBody.frame = 6;
                } else if (inRange(30, 35)) {
                    farmer.deathBody.frame = 7;
                } else if (inRange(35, 40)) {
                    farmer.deathBody.frame = 8;
                } else if (inRange(40, 45)) {
                    farmer.deathBody.frame = 9;
                } else if (inRange(45, 50)) {
                    farmer.deathBody.frame = 10;
                } else if (inRange(50, 55)) {
                    farmer.deathBody.frame = 11;
                } else if (inRange(55, 70)) {
                    farmer.deathBody.frame = 12;
                }

                game.camera.shake(.0001 * gameState.endSequence.step, 100, true, Phaser.Camera.SHAKE_HORIZONTAL);
            } else {
                // Play shot animation
                if (farmer.deathBody.frame <= 12) {
                    farmer.deathBody.animations.play("death");
                    gunshot.play("gunshot", 0, 1, false);
                }
                // End of game.
                showTitle("", false);
                game.camera.shake(0, 0, true);
            }

            console.log(gameState.endSequence.step);
        }

        function cameraTick() {
            // If targetActor is null, then targetPosition is the assumed camera position.
            var targetActor = null, targetPosition = 0;

            if (gameState.screen == "menu") targetPosition = kCamMenu * 3;
            else if (gameState.room == "end") targetActor = farmer;
            else if (gameState.room == "barn") targetPosition = kCamBarn * 3;
            else if (!gameState.hasRiddenBoat) targetPosition = 0;
            else if (losingScene == "wolf_eats_goat") targetActor = wolf;
            else if (losingScene == "goat_eats_cabbage") targetActor = goat;
            else targetActor = farmer; // outside, not losing, boat ridden.

            if (targetActor) {
                var targetCameraX = targetActor.state.x * 3 - 450;
                var camDiff = targetCameraX - game.camera.x;
                if (Math.abs(camDiff) < .01 || stateJustReset) {
                    game.camera.x = targetCameraX;
                    stateJustReset = false;
                } else {
                    var maxCamDelta = 100;
                    if (Math.abs(camDiff) > maxCamDelta) {
                        camDiff = Math.sign(camDiff) * maxCamDelta;
                    }
                    game.camera.x += game.time.elapsed * camDiff * .002;
                }
                var rightEnd = rightEnd = 3 * kCamBeforeFarm;
                if (isRiddleSolved()) {
                    rightEnd = 3 * kCamAfterFarm;
                }
                game.camera.x = Math.max(0, game.camera.x);
                game.camera.x = Math.min(rightEnd, game.camera.x);
            } else {
                game.camera.x = targetPosition;
            }
        }
    
        var waterTime = 500;
        function waterTick() {
            // At random timer interval, set velocities for velocity driven points.
            if (timerWait("water", waterTime) == 0) {
                water.data.forEach((w) => {
                    if (!w.velocityDriven) return;
                    // Only move if the water isn't moving much to prevent jitter.
                    if (Math.abs(w.sprite.y) > 3 || Math.abs(w.vel) > .5) return;
                    w.vel = Math.random() * 8 - 4;
                });
                waterTime = Math.floor(Math.random() * 1000 + 500);
                timerReset("water");
            }
            for (var i = 0; i < water.data.length; i++) {
                if (!water.data[i].velocityDriven) {
                    // Move towards average point.
                    var d1 = water.data[i-1].sprite.y - water.data[i].sprite.y;
                    var d2 = water.data[i+1].sprite.y - water.data[i].sprite.y;
                    var avg = .5 * d1 + .5 * d2;
                    water.data[i].sprite.y += avg;
                } else {
                    water.data[i].vel += .1 * Math.sign(-1 * water.data[i].sprite.y);
                    water.data[i].sprite.y += .1 * water.data[i].vel;
                    water.data[i].vel *= .991;
                }
                water.data[i].sprite.y = Math.max(-20, water.data[i].sprite.y);
                water.data[i].sprite.y = Math.min(20, water.data[i].sprite.y);
            }
        }

        roomTick["barn"] = function() {
            farmerTick();
            skyTick();
        };

        roomTick["outside"] = function() {
            if (gameState.day == 1) playIfNotPlaying("bg");
            else playIfNotPlaying("reverse");
            boatTick();
            farmerTick();
            animalTick();
            skyTick();
        };

        roomTick["end"] = function() {
            farmerTick(); // TODO separate function?
            endSequenceTick();
            playIfNotPlaying("reverse");

            // Play the noise if not already.
            if (noiseState == "unstarted") {
                noise.play("noise", 0, 0, true);
            } else {
                noise.volume = Math.min(gameState.endSequence.step / 70, 1);
            }

            if (gameState.endSequence.step >= 70) {
                noise.volume = 0;
                audioPlaying.volume = 0;
            }
        }

        screenTick["menu"] = function() {
            displayText("(space) to play");
            tickDisplayText();
            if (isPressed(Phaser.KeyCode.SPACEBAR)) {
                transitionState(1000, () => {
                    gameState.screen = "game";
                });
            }
            waterTick();
        }

        screenTick["game"] = function() {
            roomTick[gameState.room]();
            game.sound.mute = muted;
            tickDisplayText();
            waterTick();
        }

        function update() {
            // Ignore large time deltas to avoid big jumps.
            if (game.time.elapsed > 1000) return;
            screenTick[gameState.screen]();
            cameraTick();
        }

        muteButton.addEventListener("click", (e) => {
            muted = !muted;
            updateMuteButton();
            e.preventDefault();
            return false;
        }, false);
    </script>
</body>
</html>